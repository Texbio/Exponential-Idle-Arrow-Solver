<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Incremental Arrow Solver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better aesthetics */
        body {
            font-family: 'Inter', sans-serif;
        }
        .tile-container, .step-tile, .hard-mode-tile {
            aspect-ratio: 1 / 1;
            transition: all 0.2s ease-in-out;
        }
        .selector-circle, .value-circle {
            transition: all 0.2s ease-in-out;
            aspect-ratio: 1 / 1;
        }
        /* Custom class to hide the background of the main tile when selector is active */
        .selector-active {
            background-color: transparent !important;
            border-color: transparent !important;
        }
        /* Custom class for highlighting */
        .highlight {
            color: #FBBF24; /* Tailwind's yellow-400 */
            font-weight: bold;
        }
        /* Prevent text selection on clickable circles */
        .selector-circle, .value-circle, .hard-mode-tile {
            user-select: none; /* Standard syntax */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE/Edge */
        }
    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto">
        <header class="text-center mb-4">
            <h1 class="text-4xl font-bold text-white">Incremental Arrow Solver</h1>
        </header>

        <!-- Difficulty Selector -->
        <div class="flex justify-center mb-6">
            <select id="difficulty-selector" class="bg-gray-700 border border-gray-600 rounded-lg p-2 text-white focus:ring-cyan-500 focus:border-cyan-500">
                <option value="easy">Easy</option>
                <option value="medium">Medium</option>
                <option value="hard">Hard</option>
                <option value="expert">Expert</option>
            </select>
        </div>

        <main class="flex items-center justify-between gap-2 sm:gap-6">
            <!-- Control Buttons Column -->
            <div class="w-14 flex-shrink-0 flex flex-col items-center gap-2">
                <!-- Randomize Button -->
                <button id="randomize-btn" title="Randomize" class="p-2 text-gray-400 hover:text-white bg-gray-800 border border-gray-600 rounded-lg transition-colors duration-200 w-full aspect-square flex items-center justify-center">
                     <div class="flex flex-col items-center justify-center font-mono text-xs leading-none font-bold">
                        <span>12</span>
                        <span>34</span>
                    </div>
                </button>
                <!-- Reset Button -->
                <button id="reset-btn" title="Reset" class="p-2 text-gray-400 hover:text-white bg-gray-800 border border-gray-600 rounded-lg transition-colors duration-200 w-full aspect-square flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path>
                        <path d="M21 3v5h-5"></path>
                    </svg>
                </button>
            </div>

            <!-- The Board Container -->
            <div id="board-container" class="w-full max-w-xl">
                 <div id="board" class="grid gap-2 sm:gap-3">
                    <!-- Tiles will be generated by JavaScript -->
                </div>
            </div>

             <!-- Placeholder for balance -->
            <div class="w-14 flex-shrink-0"></div>
        </main>

        <!-- Board State String Input -->
        <div class="mt-4 w-full max-w-xl mx-auto">
            <label for="board-string-input" class="block text-sm font-medium text-gray-400 mb-1">Board State String</label>
            <textarea id="board-string-input" rows="2" class="w-full bg-gray-800 border border-gray-600 rounded-lg p-2 text-white text-sm focus:ring-cyan-500 focus:border-cyan-500 font-mono" placeholder="Paste board state string here..."></textarea>
        </div>

        <!-- Solve Button (for Hard/Expert modes) -->
        <div id="solve-button-container" class="text-center mt-6">
            <!-- Button will be generated by JavaScript -->
        </div>


        <!-- Status Indicator -->
        <div id="status" class="text-center h-8 mt-4">
            <!-- Messages like "Solving..." or "No Solution Found" will appear here -->
        </div>
    </div>

    <!-- Solution Steps Container -->
    <div id="solution-steps" class="w-full lg:w-4/5 mx-auto mt-8 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 min-h-[256px]">
        <!-- Step-by-step solution will be rendered here -->
    </div>

    <script>
        // --- CONFIGURATION ---
        const BACKEND_URL = 'http://127.0.0.1:8000/solve';
        const HEXAGON_LAYOUT = [4, 5, 6, 7, 6, 5, 4];

        // --- DOM ELEMENTS ---
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const solutionStepsElement = document.getElementById('solution-steps');
        const resetButton = document.getElementById('reset-btn');
        const randomizeButton = document.getElementById('randomize-btn');
        const difficultySelector = document.getElementById('difficulty-selector');
        const solveButtonContainer = document.getElementById('solve-button-container');
        const boardStringInput = document.getElementById('board-string-input');


        // --- STATE MANAGEMENT ---
        let boardState = [];
        let isSolving = false;
        let currentDifficulty = 'easy'; // Default value
        let gridSize = 3;

        // --- EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', () => {
            const savedDifficulty = localStorage.getItem('puzzleDifficulty') || 'easy';
            currentDifficulty = savedDifficulty;
            initialize();
        });

        resetButton.addEventListener('click', initialize);
        randomizeButton.addEventListener('click', handleRandomize);
        boardStringInput.addEventListener('input', handleBoardStringInput);

        difficultySelector.addEventListener('change', (e) => {
            currentDifficulty = e.target.value;
            localStorage.setItem('puzzleDifficulty', currentDifficulty);
            initialize();
        });

        function initialize() {
            difficultySelector.value = currentDifficulty;
            updateGridSize();
            isSolving = false;
            statusElement.innerHTML = '';
            solutionStepsElement.innerHTML = '';
            renderBoard();
            renderSolveButton();
            updateBoardStringInput();
        }

        function updateGridSize() {
             switch(currentDifficulty) {
                case 'expert':
                case 'hard':
                    gridSize = HEXAGON_LAYOUT.reduce((sum, val) => sum + val, 0);
                    break;
                case 'medium':
                    gridSize = 4;
                    break;
                case 'easy': default:
                    gridSize = 3;
                    break;
            }
        }

        function renderBoard() {
            boardElement.innerHTML = '';
            if (currentDifficulty === 'hard' || currentDifficulty === 'expert') {
                boardState = Array(gridSize).fill(1);
                renderHexagonalBoard();
            } else {
                boardState = Array(gridSize * gridSize).fill(null);
                renderEasyMediumBoard();
            }
        }

        function renderEasyMediumBoard() {
            boardElement.className = 'grid gap-2 sm:gap-3';
            boardElement.style.gridTemplateColumns = `repeat(${gridSize}, minmax(0, 1fr))`;
            for (let i = 0; i < gridSize * gridSize; i++) {
                const tileContainer = document.createElement('div');
                tileContainer.className = 'tile-container bg-gray-800 border border-gray-600 rounded-full p-1 sm:p-2 flex items-center justify-center selector-active';
                const selector = document.createElement('div');
                selector.className = 'selector grid grid-cols-2 gap-1 sm:gap-2 w-full h-full';
                for (let j = 1; j <= 4; j++) {
                    const numCircle = document.createElement('div');
                    numCircle.className = 'selector-circle bg-gray-700 hover:bg-gray-600 rounded-full flex items-center justify-center text-sm sm:text-lg md:text-xl font-bold cursor-pointer';
                    numCircle.textContent = j;
                    numCircle.addEventListener('click', () => handleNumberSelect(i, j));
                    selector.appendChild(numCircle);
                }
                const valueDisplay = document.createElement('div');
                valueDisplay.className = 'value-circle hidden w-full h-full bg-gray-700 border border-gray-500 rounded-full flex items-center justify-center text-4xl sm:text-5xl md:text-6xl font-bold cursor-pointer';
                valueDisplay.addEventListener('dblclick', () => handleUndo(i));
                tileContainer.appendChild(selector);
                tileContainer.appendChild(valueDisplay);
                boardElement.appendChild(tileContainer);
            }
        }

        function renderHexagonalBoard() {
            boardElement.className = 'flex justify-center items-center gap-1 sm:gap-2';
            boardElement.style.gridTemplateColumns = '';
            let tileIndex = 0;
            HEXAGON_LAYOUT.forEach(colSize => {
                const column = document.createElement('div');
                column.className = 'flex flex-col gap-1 sm:gap-2';
                for (let i = 0; i < colSize; i++) {
                    const tile = document.createElement('div');
                    tile.className = 'hard-mode-tile w-10 h-10 sm:w-12 sm:h-12 bg-gray-700 border border-gray-500 rounded-full flex items-center justify-center text-2xl font-bold cursor-pointer';
                    tile.textContent = '1';
                    tile.dataset.index = tileIndex;
                    if (currentDifficulty === 'hard') {
                        tile.addEventListener('click', () => handleHardModeClick(parseInt(tile.dataset.index)));
                    } else { // Expert
                        tile.addEventListener('click', () => handleExpertModeClick(parseInt(tile.dataset.index)));
                    }
                    column.appendChild(tile);
                    tileIndex++;
                }
                boardElement.appendChild(column);
            });
        }

        function renderSolveButton() {
            solveButtonContainer.innerHTML = '';
            if (currentDifficulty === 'hard' || currentDifficulty === 'expert') {
                const solveButton = document.createElement('button');
                solveButton.id = 'solve-btn';
                solveButton.className = 'px-6 py-2 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg transition-colors';
                solveButton.textContent = 'Solve';
                solveButton.addEventListener('click', startSolver);
                solveButtonContainer.appendChild(solveButton);
            }
        }

        function handleHardModeClick(index) {
            if (isSolving) return;
            boardState[index] = boardState[index] === 1 ? 2 : 1;
            updateTileUI(index);
            updateBoardStringInput();
        }

        function handleExpertModeClick(index) {
            if (isSolving) return;
            const currentValue = boardState[index];
            boardState[index] = (currentValue % 6) + 1;
            updateTileUI(index);
            updateBoardStringInput();
        }

        function handleUndo(index) {
            if (isSolving) return;
            boardState[index] = null;
            updateTileUI(index);
            updateBoardStringInput();
        }

        function handleNumberSelect(index, value) {
            if (isSolving || boardState[index] !== null) return;
            boardState[index] = value;
            updateTileUI(index);
            updateBoardStringInput();
            if (currentDifficulty !== 'hard' && currentDifficulty !== 'expert' && boardState.every(v => v !== null)) {
                startSolver();
            }
        }

        function handleRandomize() {
            if (isSolving) return;
            solutionStepsElement.innerHTML = '';
            const totalTiles = (currentDifficulty === 'hard' || currentDifficulty === 'expert') ? gridSize : gridSize * gridSize;

            for (let i = 0; i < totalTiles; i++) {
                if (currentDifficulty === 'hard') {
                    boardState[i] = Math.floor(Math.random() * 2) + 1;
                } else if (currentDifficulty === 'expert') {
                    boardState[i] = Math.floor(Math.random() * 6) + 1;
                } else {
                    boardState[i] = Math.floor(Math.random() * 4) + 1;
                }
                updateTileUI(i);
            }
            updateBoardStringInput();
            if (boardState.some(v => v === null)) return;
            startSolver();
        }

        function handleBoardStringInput(e) {
            const isHexMode = currentDifficulty === 'hard' || currentDifficulty === 'expert';
            const validCharsRegex = isHexMode
                ? (currentDifficulty === 'expert' ? /[^1-6]/g : /[^1-2]/g)
                : /[^0-4]/g;

            let sanitizedString = e.target.value.replace(validCharsRegex, '');
            const requiredLength = isHexMode ? gridSize : gridSize * gridSize;

            if (sanitizedString.length > requiredLength) {
                sanitizedString = sanitizedString.substring(0, requiredLength);
            }

            e.target.value = sanitizedString;

            if (sanitizedString.length === requiredLength) {
                let newBoardState = sanitizedString.split('').map(Number);
                if (!isHexMode) {
                    newBoardState = newBoardState.map(val => val === 0 ? null : val);
                }
                boardState = newBoardState;
                for (let i = 0; i < requiredLength; i++) {
                    updateTileUI(i);
                }
                // --- THIS IS THE FIX ---
                // After updating from string, check if the board is full for easy/medium modes and auto-solve.
                if (!isHexMode && boardState.every(v => v !== null)) {
                    startSolver();
                }
            }
        }

        function updateBoardStringInput() {
            const isHexMode = currentDifficulty === 'hard' || currentDifficulty === 'expert';
            let displayString = '';
            if (isHexMode) {
                displayString = boardState.join('');
            } else {
                displayString = boardState.map(v => (v === null ? '0' : v)).join('');
            }
            boardStringInput.value = displayString;
        }

        function updateTileUI(index) {
            if (currentDifficulty === 'hard' || currentDifficulty === 'expert') {
                const tile = boardElement.querySelector(`[data-index='${index}']`);
                if (tile) {
                    tile.textContent = boardState[index];
                }
            } else {
                 const tile = boardElement.children[index];
                const selector = tile.querySelector('.selector');
                const valueDisplay = tile.querySelector('.value-circle');
                const value = boardState[index];
                if (value === null) {
                    tile.classList.add('selector-active');
                    selector.classList.remove('hidden');
                    valueDisplay.classList.add('hidden');
                } else {
                    tile.classList.remove('selector-active');
                    selector.classList.add('hidden');
                    valueDisplay.textContent = value;
                    valueDisplay.classList.remove('hidden');
                }
            }
        }

        async function startSolver() {
            if (isSolving) return;
            isSolving = true;
            statusElement.textContent = 'Solving...';
            statusElement.className = 'text-center h-8 text-yellow-400 animate-pulse';
            solutionStepsElement.innerHTML = '';

            let boardPayload;
            if (currentDifficulty === 'hard' || currentDifficulty === 'expert') {
                boardPayload = boardState;
            } else {
                const initialBoard2D = [];
                const numCols = gridSize;
                for (let i = 0; i < numCols; i++) {
                    initialBoard2D.push(boardState.slice(i * numCols, i * numCols + numCols));
                }
                boardPayload = initialBoard2D;
            }

            try {
                const response = await fetch(BACKEND_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ board: boardPayload, difficulty: currentDifficulty })
                });
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

                const data = await response.json();
                const solutionSteps = data.solution_steps;

                if (solutionSteps && solutionSteps.length > 0) {
                    statusElement.textContent = `Solution found in ${solutionSteps.length} steps!`;
                    statusElement.className = 'text-center h-8 text-green-400';
                    displaySolutionSteps(solutionSteps);
                } else {
                    statusElement.textContent = 'No solution found for this configuration.';
                    statusElement.className = 'text-center h-8 text-red-500';
                }
            } catch (error) {
                console.error('Error fetching solution:', error);
                statusElement.textContent = 'Error connecting to solver backend.';
                statusElement.className = 'text-center h-8 text-red-500';
            }
            isSolving = false;
        }

        function displaySolutionSteps(steps) {
            solutionStepsElement.innerHTML = '';
            steps.forEach((step, index) => {
                const stepElement = createStepDisplay(index + 1, step.board_state, step.affected_tiles, step.click);
                solutionStepsElement.appendChild(stepElement);
            });
        }

        function createStepDisplay(stepNumber, boardData, affectedTiles, click) {
            const container = document.createElement('div');
            container.className = 'bg-gray-800 border border-gray-700 rounded-lg p-2 sm:p-3 overflow-x-auto';

            const header = document.createElement('h3');
            header.className = 'text-center text-sm text-gray-400 mb-2';

            if (currentDifficulty === 'hard' || currentDifficulty === 'expert') {
                header.textContent = `Step ${stepNumber}: Click Tile ${click + 1}`;
                container.appendChild(header);
                container.appendChild(createHexagonalGrid(boardData, affectedTiles));
            } else {
                header.textContent = `Step ${stepNumber}: Click (${click[0]+1}, ${click[1]+1})`;
                container.appendChild(header);
                container.appendChild(createSquareGrid(boardData, affectedTiles));
            }
            return container;
        }

        function createSquareGrid(boardData, affectedTiles) {
            const grid = document.createElement('div');
            grid.style.gridTemplateColumns = `repeat(${gridSize}, minmax(0, 1fr))`;
            grid.className = 'grid gap-2';

            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const tile = document.createElement('div');
                    tile.className = 'step-tile bg-gray-700 rounded-full flex items-center justify-center text-xl font-bold';
                    const index = r * gridSize + c;
                    tile.textContent = boardData[index];

                    if (affectedTiles.includes(index)) {
                        tile.classList.add('highlight');
                    }
                    grid.appendChild(tile);
                }
            }
            return grid;
        }

        function createHexagonalGrid(boardData, affectedTiles) {
            const grid = document.createElement('div');
            grid.className = 'flex justify-center items-center gap-1';
            let tileIndex = 0;
            HEXAGON_LAYOUT.forEach(colSize => {
                const column = document.createElement('div');
                column.className = 'flex flex-col gap-1';
                for (let i = 0; i < colSize; i++) {
                    const tile = document.createElement('div');
                    tile.className = 'step-tile w-6 h-6 md:w-7 md:h-7 bg-gray-700 rounded-full flex items-center justify-center font-bold text-xs md:text-sm';
                    tile.textContent = boardData[tileIndex];
                    if (affectedTiles.includes(tileIndex)) {
                        tile.classList.add('highlight');
                    }
                    column.appendChild(tile);
                    tileIndex++;
                }
                grid.appendChild(column);
            });
            return grid;
        }
    </script>
</body>
</html>
